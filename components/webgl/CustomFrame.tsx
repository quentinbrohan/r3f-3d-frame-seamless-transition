/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { JSX, useEffect, useRef, useState } from 'react'
import * as THREE from 'three'
import { GLTF } from 'three-stdlib'
import { useCursor } from '@react-three/drei'
import { mergeRefs } from '@/lib/utils'

export const DEFAULT_FRAME_SCALE = 0.02;
// from planeRef geometry computeBoundingBox
export const FRAME_PLANE_WIDTH = 59.384
export const FRAME_PLANE_HEIGHT = 87.672

type GLTFResult = GLTF & {
    nodes: {
        model: THREE.Mesh
        Plane002: THREE.Mesh
    }
    materials: {
        ['CustomMaterial.001']: THREE.MeshStandardMaterial
    }
}

const MODEL_PATH = '/webgl/models/custom-frame-draco-compressed.glb'
useGLTF.preload(MODEL_PATH)

interface CustomFrameProps {
    image: string;
    position?: [number, number, number]
    rotation?: [number, number, number]
    envMap?: THREE.Texture
    lookAtCamera?: boolean
    isFloating?: boolean;
    isFollowingCursor?: boolean;
    index: number;
}

export function CustomFrame(props: JSX.IntrinsicElements['group'] & CustomFrameProps) {
    const {
        image,
        envMap,
        lookAtCamera,
        isFloating = false,
        isFollowingCursor = true,
        ref,
        index
    } = props
    const groupRef = useRef<THREE.Group | null>(null)
    const planeRef = useRef<THREE.Mesh | null>(null)


    const { nodes, materials } = useGLTF(MODEL_PATH) as unknown as GLTFResult
    const texture = useTexture(image)
    const metalFilenameBase = 'Metal003_1K-JPG'
    const metalBasePath = `/webgl/textures/${metalFilenameBase}`
    const combinedPathPrefix = `${metalBasePath}/${metalFilenameBase}`
    const metalTextures = useTexture({
        map: `${combinedPathPrefix}_Color.jpg`,
        normalMap: `${combinedPathPrefix}_NormalGL.jpg`,
        roughnessMap: `${combinedPathPrefix}_Roughness.jpg`,
        metalnessMap: `${combinedPathPrefix}_Metalness.jpg`,
        // displacementMap: `${combinedPath}_Displacement.jpg`,
    })

    const { camera } = useThree()
    const mouse = useRef({ x: 0, y: 0 })

    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            mouse.current.x = (e.clientX / window.innerWidth - 0.5)
            mouse.current.y = (0.5 - e.clientY / window.innerHeight)
        }

        window.addEventListener('mousemove', handleMouseMove)
        return () => window.removeEventListener('mousemove', handleMouseMove)
    }, [])


    const [hovered, set] = useState(false)
    useCursor(hovered && isFollowingCursor)

    if (texture) texture.flipY = false

    const handleMouseMove = (event: any) => {
        mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1
    }

    useFrame((state) => {
        if (!groupRef.current) return

        const elapsed = state.clock.elapsedTime

        const targetY = isFloating ? Math.sin(elapsed * 0.6) * 0.15 : 0

        groupRef.current.position.y += (targetY - groupRef.current.position.y) * 0.1

        const target = lookAtCamera ? camera.position : new THREE.Vector3(0, 0, 0)

        const tempObject = new THREE.Object3D()
        tempObject.position.copy(groupRef.current.position)
        tempObject.lookAt(target)
        const lookAtQuat = tempObject.quaternion.clone()

        const mouseInfluence = 0.1
        const horizontalScale = 1.4 * 3

        const eulerOffset = new THREE.Euler(
            Math.cos(elapsed * 0.5) * 0.03 + -mouse.current.y * mouseInfluence,
            Math.sin(elapsed * 0.4) * 0.08 + mouse.current.x * mouseInfluence * horizontalScale,
            Math.sin(elapsed * 0.3) * 0.02,
            'XYZ'
        )

        const offsetQuat = new THREE.Quaternion()
        offsetQuat.setFromEuler(eulerOffset)

        if (isFollowingCursor) {
            lookAtQuat.multiply(offsetQuat)
        }

        groupRef.current.quaternion.slerp(lookAtQuat, 0.125) // 0.125 = lerp speed (adjust for smoothness)
    })

    // debug only to get frame width
    // useEffect(() => {
    //     if (!planeRef.current) return;

    //     const mesh = planeRef.current;

    //     // compute bounding box *of the geometry*
    //     const geo = mesh.geometry;
    //     geo.computeBoundingBox();

    //     const { boundingBox } = geo;
    //     const width = boundingBox.max.x - boundingBox.min.x;
    //     const height = boundingBox.max.y - boundingBox.min.y;

    //     console.log("width:", width, "height:", height);

    //     // size including scale/transform
    //     const box = new THREE.Box3().setFromObject(planeRef.current);
    //     const size = new THREE.Vector3();
    //     box.getSize(size);

    //     console.log("scaled width:", size.x);
    //     console.log("scaled height:", size.y);
    // }, []);

    return (
        <group {...props} dispose={null}
            scale={DEFAULT_FRAME_SCALE}
            ref={mergeRefs(groupRef, ref)}
            onPointerMove={handleMouseMove}
            name={`Frame ${index}`}
        >
            <mesh
                name="model"
                castShadow
                receiveShadow
                geometry={nodes.model.geometry}
                material={materials['CustomMaterial.001']}
                position={[0, -73.26, 0.327]}
                rotation={[Math.PI / 2, 0, 0]}
                scale={79.651}
            >
                <meshStandardMaterial
                    {...metalTextures}
                    // displacementScale={0.1}
                    metalness={1}
                    roughness={0.1}
                    envMap={envMap}
                    envMapIntensity={3}

                />
            </mesh>
            <mesh
                ref={planeRef}
                name="Plane002"
                castShadow
                receiveShadow
                geometry={nodes.Plane002.geometry}
                material={nodes.Plane002.material}
                onPointerOver={() => set(true)} onPointerOut={() => set(false)}
            >
                <meshStandardMaterial
                    map={texture}
                    transparent={false}
                />
            </mesh>
        </group>
    )
}
