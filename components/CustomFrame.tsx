/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { JSX, useEffect, useRef, useState } from 'react'
import * as THREE from 'three'
import { GLTF } from 'three-stdlib'
import { useCursor } from '@react-three/drei'

type GLTFResult = GLTF & {
    nodes: {
        model: THREE.Mesh
        Plane002: THREE.Mesh
    }
    materials: {
        ['CustomMaterial.001']: THREE.MeshStandardMaterial
    }
}

interface CustomFrameProps {
    image: string;
    onThroughPlane: () => void
    isMovingThrough: boolean
    position?: [number, number, number]
    rotation?: [number, number, number]
    envMap?: THREE.Texture
    lookAtCamera?: boolean
    isFloating?: boolean;
    isFollowingCursor?: boolean;

}

export function CustomFrame(props: JSX.IntrinsicElements['group'] & CustomFrameProps) {
    const {
        onThroughPlane,
        isMovingThrough,
        image,
        envMap,
        lookAtCamera,
        isFloating = false,
        isFollowingCursor = true,
    } = props
    const groupRef = useRef()
    const planeRef = useRef()


    const { nodes, materials } = useGLTF('/custom-frame.glb') as GLTFResult
    const texture = useTexture(image)
    const metalBasePath = '/images/Metal003_1K-JPG'
    const metalBaseName = 'Metal003_1K-JPG'
    const combinedPath = `${metalBasePath}/${metalBaseName}`
    const metalTextures = useTexture({
        map: `${combinedPath}_Color.jpg`,
        normalMap: `${combinedPath}_NormalGL.jpg`,
        roughnessMap: `${combinedPath}_Roughness.jpg`,
        metalnessMap: `${combinedPath}_Metalness.jpg`,
        // displacementMap: `${combinedPath}_Displacement.jpg`,
    })

    const { camera } = useThree()
    // const mouse = useRef(new THREE.Vector2(0, 0))
    // At the top-level of your component
    const mouse = useRef({ x: 0, y: 0 })

    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            // Normalize to [-0.5, 0.5], 0 at center
            mouse.current.x = (e.clientX / window.innerWidth - 0.5)
            mouse.current.y = (0.5 - e.clientY / window.innerHeight) // invert Y for natural rotation
        }

        window.addEventListener('mousemove', handleMouseMove)
        return () => window.removeEventListener('mousemove', handleMouseMove)
    }, [])


    const [hovered, set] = useState(false)
    useCursor(hovered, /*'pointer', 'auto', document.body*/)

    if (texture) texture.flipY = false

    const handleDoubleClick = (event: any) => {
        event.stopPropagation()
        onThroughPlane()
    }

    const handleMouseMove = (event: any) => {
        // Convert mouse position to normalized device coordinates (-1 to +1)
        mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1
    }

    useFrame((state) => {
        if (!groupRef.current) return

        const elapsed = state.clock.elapsedTime

        // --- Floating vertical motion ---
        if (isFloating) {
            const baseY = Math.sin(elapsed * 0.6) * 0.15
            groupRef.current.position.y = baseY
        }

        // --- Determine look-at target ---
        const target = lookAtCamera ? camera.position : new THREE.Vector3(0, 0, 0)

        // Compute look-at quaternion
        const lookAtQuat = new THREE.Quaternion()
        groupRef.current.lookAt(target)
        lookAtQuat.copy(groupRef.current.quaternion)

        // --- Mouse & floating offsets ---
        const mouseInfluence = 0.1       // Increase for more noticeable motion
        const horizontalScale = 1.4 * 3      // Adjust for A3 width

        const eulerOffset = new THREE.Euler(
            Math.cos(elapsed * 0.5) * 0.03 + mouse.current.y * mouseInfluence,                // X rotation
            Math.sin(elapsed * 0.4) * 0.08 + mouse.current.x * mouseInfluence * horizontalScale, // Y rotation
            Math.sin(elapsed * 0.3) * 0.02,                                                  // Z rotation
            'XYZ'
        )

        const offsetQuat = new THREE.Quaternion()
        offsetQuat.setFromEuler(eulerOffset)


        // --- Apply combined rotation ---
        groupRef.current.quaternion.copy(lookAtQuat)
        if (isFollowingCursor) {
            groupRef.current.quaternion.multiply(offsetQuat)
        }
    })

    return (
        <group {...props} dispose={null}
            // scale={0.04}
            // scale={0.02}
            scale={0.02}
            // scale={[1, 1, 1]}
            ref={groupRef}
            onPointerMove={handleMouseMove}

        >
            <mesh
                name="model"
                castShadow
                receiveShadow
                geometry={nodes.model.geometry}
                material={materials['CustomMaterial.001']}
                position={[0, -73.26, 0.327]}
                rotation={[Math.PI / 2, 0, 0]}
                scale={79.651}
            >
                <meshStandardMaterial
                    // color="#808080"
                    // color="#f1f3f9"
                    // metalness={1}
                    // roughness={0.2}
                    // envMapIntensity={2}
                    {...metalTextures}
                    displacementScale={0.1} // Adjust to taste
                    metalness={1}
                    roughness={0.1}
                    envMap={envMap}
                    envMapIntensity={3}  // try 2â€“5 to see what fits best

                />
                {/* <meshStandardMaterial color="#c0c0c0" metalness={0.9} roughness={0.1} envMapIntensity={1.5} /> */}
            </mesh>
            <mesh
                ref={planeRef}
                name="Plane002"
                castShadow
                receiveShadow
                geometry={nodes.Plane002.geometry}
                material={nodes.Plane002.material}
                onDoubleClick={handleDoubleClick}
                onPointerOver={() => set(true)} onPointerOut={() => set(false)}

            >
                <meshStandardMaterial
                    map={texture}
                    transparent={false}
                />
            </mesh>
        </group>
    )
}

useGLTF.preload('/custom-frame.glb')