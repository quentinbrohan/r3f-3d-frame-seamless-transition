/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { JSX, useEffect, useRef, useState } from 'react'
import * as THREE from 'three'
import { GLTF } from 'three-stdlib'
import { useCursor } from '@react-three/drei'
import { mergeRefs } from '@/lib/utils'

export const DEFAULT_FRAME_SCALE = 0.02;
// from planeRef geometry computeBoundingBox
export const FRAME_PLANE_WIDTH = 59.384
export const FRAME_PLANE_HEIGHT = 87.672

type GLTFResult = GLTF & {
    nodes: {
        model: THREE.Mesh
        Plane002: THREE.Mesh
    }
    materials: {
        ['CustomMaterial.001']: THREE.MeshStandardMaterial
    }
}

interface CustomFrameProps {
    image: string;
    position?: [number, number, number]
    rotation?: [number, number, number]
    envMap?: THREE.Texture
    lookAtCamera?: boolean
    isFloating?: boolean;
    isFollowingCursor?: boolean;
}

export function CustomFrame(props: JSX.IntrinsicElements['group'] & CustomFrameProps) {
    const {
        image,
        envMap,
        lookAtCamera,
        isFloating = false,
        isFollowingCursor = true,
        ref,
    } = props
    const groupRef = useRef()
    const planeRef = useRef()


    const { nodes, materials } = useGLTF('/custom-frame.glb') as GLTFResult
    const texture = useTexture(image)
    const metalBasePath = '/images/Metal003_1K-JPG'
    const metalBaseName = 'Metal003_1K-JPG'
    const combinedPath = `${metalBasePath}/${metalBaseName}`
    const metalTextures = useTexture({
        map: `${combinedPath}_Color.jpg`,
        normalMap: `${combinedPath}_NormalGL.jpg`,
        roughnessMap: `${combinedPath}_Roughness.jpg`,
        metalnessMap: `${combinedPath}_Metalness.jpg`,
        // displacementMap: `${combinedPath}_Displacement.jpg`,
    })

    const { camera } = useThree()
    // const mouse = useRef(new THREE.Vector2(0, 0))
    // At the top-level of your component
    const mouse = useRef({ x: 0, y: 0 })

    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            // Normalize to [-0.5, 0.5], 0 at center
            mouse.current.x = (e.clientX / window.innerWidth - 0.5)
            mouse.current.y = (0.5 - e.clientY / window.innerHeight) // invert Y for natural rotation
        }

        window.addEventListener('mousemove', handleMouseMove)
        return () => window.removeEventListener('mousemove', handleMouseMove)
    }, [])


    const [hovered, set] = useState(false)
    // TODO: update, only hover in list page when overlay closed, atm cursor follow only in this case
    useCursor(hovered && isFollowingCursor, /*'pointer', 'auto', document.body*/)

    if (texture) texture.flipY = false

    const handleMouseMove = (event: any) => {
        // Convert mouse position to normalized device coordinates (-1 to +1)
        mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1
    }

    useFrame((state) => {
        if (!groupRef.current) return

        const elapsed = state.clock.elapsedTime

        // --- Floating vertical motion with smooth transition ---
        const targetY = isFloating ? Math.sin(elapsed * 0.6) * 0.15 : 0

        // Smoothly interpolate to target Y position
        groupRef.current.position.y += (targetY - groupRef.current.position.y) * 0.1

        // --- Determine look-at target ---
        const target = lookAtCamera ? camera.position : new THREE.Vector3(0, 0, 0)

        // Compute target look-at quaternion
        const tempObject = new THREE.Object3D()
        tempObject.position.copy(groupRef.current.position)
        tempObject.lookAt(target)
        const lookAtQuat = tempObject.quaternion.clone()

        // --- Mouse & floating offsets ---
        const mouseInfluence = 0.1
        const horizontalScale = 1.4 * 3

        const eulerOffset = new THREE.Euler(
            Math.cos(elapsed * 0.5) * 0.03 + -mouse.current.y * mouseInfluence,
            Math.sin(elapsed * 0.4) * 0.08 + mouse.current.x * mouseInfluence * horizontalScale,
            Math.sin(elapsed * 0.3) * 0.02,
            'XYZ'
        )

        const offsetQuat = new THREE.Quaternion()
        offsetQuat.setFromEuler(eulerOffset)

        // Apply offset if following cursor
        if (isFollowingCursor) {
            lookAtQuat.multiply(offsetQuat)
        }

        // --- SMOOTH TRANSITION: Lerp quaternion instead of direct copy ---
        groupRef.current.quaternion.slerp(lookAtQuat, 0.125) // 0.125 = lerp speed (adjust for smoothness)
    })

    // debug only to get frame width
    useEffect(() => {
        if (!planeRef.current) return;

        const mesh = planeRef.current;

        // compute bounding box *of the geometry*
        const geo = mesh.geometry;
        geo.computeBoundingBox();

        const { boundingBox } = geo;
        const width = boundingBox.max.x - boundingBox.min.x;
        const height = boundingBox.max.y - boundingBox.min.y;

        console.log("width:", width, "height:", height);

        // size including scale/transform
        const box = new THREE.Box3().setFromObject(planeRef.current);
        const size = new THREE.Vector3();
        box.getSize(size);

        console.log("scaled width:", size.x);
        console.log("scaled height:", size.y);
    }, []);

    return (
        <group {...props} dispose={null}
            scale={DEFAULT_FRAME_SCALE}
            ref={mergeRefs(groupRef, ref)}
            onPointerMove={handleMouseMove}

        >
            <mesh
                name="model"
                castShadow
                receiveShadow
                geometry={nodes.model.geometry}
                material={materials['CustomMaterial.001']}
                position={[0, -73.26, 0.327]}
                rotation={[Math.PI / 2, 0, 0]}
                scale={79.651}
            >
                <meshStandardMaterial
                    {...metalTextures}
                    displacementScale={0.1} // Adjust to taste
                    metalness={1}
                    roughness={0.1}
                    envMap={envMap}
                    envMapIntensity={3}  // try 2â€“5 to see what fits best

                />
                {/* <meshStandardMaterial color="#c0c0c0" metalness={0.9} roughness={0.1} envMapIntensity={1.5} /> */}
            </mesh>
            <mesh
                ref={planeRef}
                name="Plane002"
                castShadow
                receiveShadow
                geometry={nodes.Plane002.geometry}
                material={nodes.Plane002.material}
                onPointerOver={() => set(true)} onPointerOut={() => set(false)}
            >
                <meshStandardMaterial
                    map={texture}
                    transparent={false}
                />
            </mesh>
        </group>
    )
}

useGLTF.preload('/custom-frame.glb')